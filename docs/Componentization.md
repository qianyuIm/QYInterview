# 组件化
谈到**组件化**，首先想到的是**解耦**，**模块化**。其实组件化就是将**模块化抽离**，**分层**，并制定**模块间的通讯方式**，从而实现**解耦**的一种方式，**主要运用在团队开发和项目较多的团队**。

## 为什么要组件化?
主要有以下四个原因:			

* 1.模块间解耦
* 2.模块复用
* 3.提高团队协作开发效率
* 4.方便进行单元测试

当项目因为各种需求，越来越大时，如果此时各个模块间 **相互调用**，即 **你中有我，我中有你**这种情况时，会造成 **高耦合** 的情况，一旦我们需要对某一块代码 **进行修改** 时，就会 **牵一发而动全身**，导致项目难以维护。其问题主要体现再以下几个方面:

* 1. 修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有对该模块的引用，可以理解为 **高耦合导致代码修改空难**
* 2. 模块对外接口不明确，设置暴露了本不该暴露的私有接口，修改时费时费力，可以理解为 **接口不固定导致的接口混乱**
* 3，高耦合的代码会影响团队其他成员的开发，导致**代码冲突**
* 4. 当模块要重用到其他项目时，**难以单独分离**

所以为了解决以上问题，我们需要采用 **更规范的方式** 来 **降低模块间的耦合度**，然后组件化就应运而生了，**组件化**也可以理解为**模块化**。
## 组件原则
项目通常分为三层，从上到下 即: 业务层，通用层，基础层。

只能上层对下层依赖，不能下层对上层依赖，业务层横向的依赖也尽量减少，最好下层至通用层或者基础层。
## 组件化方案
目前常用的组件化方案主要有两种:

* 第一种是**本地**组件化，在工程中创建**library**，利用 **cocoapods**的**workspec**进行本地管理，**不需要**将项目上传到**git**,而是直接在项目中**以framework的方式**进行调用。
* 第二种**cocoapods**组件化，主要是利用**cocoapods**来进行**模块远程管理**，需要将项目上传git(分为公有库和私有库，对公司而言，一般是私有库)

## 组件化通讯方案
目前主流的主要有两种:

* 1. **URL** 路由 代表为 MGJRouter
* 2. **target-action** 代表为 CTMediator

**URL路由**

定义一个Router单例，使用前需要注册组件，调用方通过URL调用服务方页面，通过路由表的映射关系进行关联，调用方可以传入复杂的参数，对象等。

优点:		

1. 有很高的动态性，适合经常展开运营活动的app,如电商类。
2. 方便统一管理多平台的路由规则
3. 易于适配URL Scheme

缺点：

1. 解耦能力有限，URL注册，实现，使用必须使用相同的字符串规则，一旦任何一方做出修改都会导致其他地方的代码失效。
2. 需要注册URL，会造成浪费内存
3. 无法保证所有使用的模块一定存在
4. 依赖于字符串硬编码，难以管理。
5. 参数格式不明确，是个灵活的字典，还需要有个地方查看参数格式

**target-action路由**
这个方案基于OC的runtime, category特性**动态获取模块**，通过**NSClassFromString**获取类并创建实例，通过**performSelector+NSInvocation**动态调用方法。

CTMediator的实现思路是:

1. 利用分类为路由创建新的接口，在接口中通过字符串获取对应的类
2. 通过runtime创建实例，动态调用实例的方法

优点:
1. 不需要注册URL
2. 区分了app内部调用和外部调用
3. 利用分类可以声明接口，进行**编译检查(方法声明未实现)**。

缺点:

1. 需要在mediator和target中重新添加每一个接口，模块化代码较为繁琐。
2. 在category中仍需要引入字符串硬编码，内部使用字典传参
3. 无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误
4. 创建过多的target类，导致target类泛滥
 
最佳实践: 基于URL和Target-Action，利用runtime实现Target-Action模式设计，通过定义URL协议确定Target和Action，通过params来传递所有页面间调用的参数，error返回调用的错误信息，completion来实现调用后的回调。相当于在CTMediator本地组件调用入口进行一层URL解析的封装
